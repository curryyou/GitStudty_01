Git 버전(이력) 관리
====

## **Git 이력 관리란?**
### : Git을 설정하면, 파일들의 수정 이력들을 저장하고 언제든지 과거로 돌아갈 수 있다.
<br><br>

## **Git 설정: init**
### : 특정 디렉터리를 git repisitory로 만들고, git을 통해 관리하도록 설정
### : 디렉터리에 .git 숨김 폴더가 생성되며, 파일들의 변경 '역사'가 저장된다.
>`git init 경로`

>`git init`
##### * 경로를 생락하면 현재 경로가 git repository가 된다.

<br><br>

## **3가지 영역**
### Git은 파일을 세가지 영역으로 구분하여 관리한다.
| Working Tree | Staging Area | Repository |
|:------------:|:------------:|:----------:|
|생성/수정한 파일들|버전을 생성할 후보들|실제 저장된 버전들|
<br>

### 1. 워킹 트리 : 파일을 작업(생성/수정)하는 환경.워킹 디렉터리라고도 한다.
##### * 그냥 내가 작업하는 폴더 공간과 비슷한 개념이다.
##### * 이 상태의 파일들은 git이 관리하지 않는다.(untracked상태)
### 2. 스테이징 : 작업한 파일들을 버전으로 만들기 위해 후보로 올려두는 공간
##### * 이때부터 git이 관리하기 시작한다.(tracked상태)
##### * tracked 상태가 된 파일에 변경사항이 발생하면 git이 모두 파악한다.
#### 3. 레퍼지터리 : 실제 버전으로 등록하여 저장하는 공간
##### * commit을 하면 레퍼지터리에 버전으로 등록된다.
<br>

> `git status`: Working Tree, Staging Area 의 현황 확인 명령어
##### -s, -v, -b 등의 옵션 제공


<br><br>

## **Staging 추가 : add**
### : 워킹트리에 있는 파일들을 스테이징에 등록하여 Git이 관리할 수 있도록 하는 작업
### 1) untracked 상태 : 파일이 처음 생성되어 Git이 관리하지 않는 상태
### 2) tracked 상태 : Staging Area의 커밋 후보군으로 등록되어 Git이 관리하는 상태
> `git add 파일명` : 파일 1개 등록

> `git add .` : 현재 경로의 모든 파일 등록

<br><br>

## **Repository 추가 : commit**
### : Staging Area에 있는 파일들을 Repository에 버전으로 저장하는 작업
> `git commit`

> `git commit -m '메시지'` : '커밋메시지'를 함께 입력

> `git commit -am '메시지'` : tracked된 파일들의 add와 commit 동시 수행 (최초 생성된 untracked 파일은 불가)


##### * `git commit` 은 Staging Area에 있는 **'모든 파일들'** 을 Repository로 등록하여 버전을 생성한다. 
##### * `git --amend` 나 `git --amend -m '메시지'`로 마지막 커밋의 메시지를 수정할 수 있다.

<br><br>

## **파일 수정**
### commit된 파일에 수정이 발생하면,
### ***modified*** 상태가 되면서 다시 Working Tree 에 들어간다.
### 다시 add, commit 해주면 '새로운 버전'으로 저장된다.
> `git commit -am '메시지'`
##### * 스테이징에 등록된 적이 있는 tracked상태의 파일은 -am 옵션으로 한번에 add, commit을 수행할 수 있다.
<br><br>


## **커밋 로그 확인**
### 커밋 이력을 확인할 수 있다.

> `git log` : 기본 커밋 이력

> `git log --p` : 변경된 상세 이력(차이점)

> `git log --stat` : 연관된 파일을 보여줌

> `git log --oneline` : 한줄로 제목만 보여줌

> `git log --all` : 모든 브랜치의 로그를 보여줌

> `git log --decorate` : Branch, HEAD 정보도 보여줌

> `git log --graph` : 그래프로 시각적으로보여줌

<br><br>

## **커밋간 차이점 확인 : diff**
### 파일을 수정했을 때,
### commit 된 마지막 버전과의 차이를 확인할 수 있다.
> `git diff`

<br><br>

## **커밋 이동 : checkout**
### 1. 과거로 회귀
#### 현재 작업 커밋을 가르키는 HEAD의 위치를 조정하여 과거로 돌아갈 수 있다.
#### 워킹 트리의 환경도 완벽하게 과거로 회기한다.
> `git checkout 과거커밋ID`
##### *과거로 돌아가도, 최신 커밋들은 그대로 남아있다. HEAD만 과거로 이동할 뿐!*

<br>

### 2. 현재로 복귀
#### HEAD가 브랜치를 가르키도록 하면, 다시 최신 커밋으로 돌아온다.
> `git checkout master`
##### * 원래 checkout은 브랜치를 변경하는 용도로 주로 사용한다.
##### * HEAD는 브랜치를 가르키는 용도로 사용되는 포인터인데, 커밋ID를 가르킬 수도 있다.

<br><br>

## **커밋 삭제 : reset**
### 특정 버전 '이후'의 커밋들을 삭제한다.
### 살아남은 특정 버전이 최신 상태의 커밋이 된다.
> `git reset --hard 커밋ID`
##### * 최신 버전들을 삭제해서 과거로 돌아가는 과격한 방법이다.

<br><br>

## **커밋 상쇄 : revert**
### 최신 커밋을 상쇄시켜서 ***그 전의 상태로 되돌리는*** 커밋을 수행한다.
### 즉, 새로운 커밋을 만들어서 과거 상태와 동일하게 만든다.

> `git revert 커밋ID` : '커밋ID'의 ***바로 전 단계***와 동일한 상태가 된다.

> `git revert HEAD` : 직전 커밋만 상쇄시킬때는 HEAD를 사용해도 된다.

> `git revert 과거커밋ID .. 최신커밋ID` : 여러 커밋 상쇄
##### * 여러 단계 전의 과거로 돌아가려면, 최신 커밋부터 역순으로 하나씩 revert해주어야 하지만, 위처럼 범위 연산자를 활용하면 한번에 상쇄시킬 수 있다.*
##### * 아무런 커밋도 삭제되지 않으므로 reset보다 안전하게 과거로 돌아가는 방법이다.





